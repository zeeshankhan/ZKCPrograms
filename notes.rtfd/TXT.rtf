{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Verdana;\f2\fnil\fcharset0 LucidaGrande;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid301\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid401\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
{\info
{\author Zeeshan Khan}
{\*\company zeeshan}
{\*\copyright Zeeshan Khan}}\paperw11900\paperh16840\margl1440\margr1440\vieww17840\viewh13740\viewkind0
\deftab720
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0\fs24 \cf0  
\f1\b\fs48 \expnd0\expndtw0\kerning0
A little C - 
\fs36 \expnd0\expndtw0\kerning0
PEMDAS - MD and AS are equal, go left-right
\b0\fs24 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
\
Other Questions
\b0 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Define, create, initiate and assign a value in a structure?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
How to use a structure in C?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
How to use memset?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
What are hashing mechanism? What is SHA256 or 128 hashing? How is it diff from others?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
Explain keychain in OS X/iOS?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	6.	}\expnd0\expndtw0\kerning0
How to use char array / sprintf / size_t ?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	7.	}\expnd0\expndtw0\kerning0
What is PKCS5_PBKDF2_HMAC (mob_key_derive)?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	8.	}\expnd0\expndtw0\kerning0
Kind of encryption famous.. like aes and their differences..?\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
\ul \ulc0 Abstract Data Structures
\b0 \expnd0\expndtw0\kerning0
\ulnone :\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Linked list\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Tree (Non-Linear)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Graph (Non-Linear)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Stack (Linear)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Queue (Linear)\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\

\b \expnd0\expndtw0\kerning0
\ul Algorithms
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Time Complexity - Amount of time needed by the program to run to completion.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Space Complexity - Amount of memory space required by the algorithm during the course of its execution.\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\

\b \expnd0\expndtw0\kerning0
\ul Time Complexity\expnd0\expndtw0\kerning0
\ulnone : 
\i \expnd0\expndtw0\kerning0
(n approaches infinity) {\field{\*\fldinst{HYPERLINK "http://bigocheatsheet.com/"}}{\fldrslt 
\i0 \cf2 \expnd0\expndtw0\kerning0
http://bigocheatsheet.com}}
\i0\b0 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0
\b \cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9642 	}\expnd0\expndtw0\kerning0
Constant
\b0 \expnd0\expndtw0\kerning0
: Just a statement running n times. 
\b \expnd0\expndtw0\kerning0
\ul n
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\ls4\ilvl0
\b \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9642 	}\expnd0\expndtw0\kerning0
Linear
\b0 \expnd0\expndtw0\kerning0
: A loop running n times. 
\b \expnd0\expndtw0\kerning0
\ul O(n)
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\ls4\ilvl0
\b \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9642 	}\expnd0\expndtw0\kerning0
Quadratic
\b0 \expnd0\expndtw0\kerning0
: A nested loop running n times. 
\b \expnd0\expndtw0\kerning0
\ul O(n2)
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\ls4\ilvl0
\b \kerning1\expnd0\expndtw0 {\listtext	\uc0\u9642 	}\expnd0\expndtw0\kerning0
Logarithmic
\b0 \expnd0\expndtw0\kerning0
: Break a set of numbers in halves. The algorithm divides the working area in half with each iteration. (Quick sort). 
\b \expnd0\expndtw0\kerning0
\ul log(n)
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
	In quick sort
\b0 \expnd0\expndtw0\kerning0
: We divide the list into halves every time (i.e. logarithmic), but we repeat the iteration N times (where n is size of list). Hence, time complexity will be 
\b \expnd0\expndtw0\kerning0
\ul n*log(n)
\b0 \expnd0\expndtw0\kerning0
\ulnone . The running time consists of N loops (iterative or recursive) that are logarithmic, thus the Quick Sort algorithm is a combination of linear and logarithmic time complexity algorithms.\
\pard\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\ul \ulc2 \
{\field{\*\fldinst{HYPERLINK "http://www.studytonight.com/data-structures/time-complexity-of-algorithms"}}{\fldrslt http://www.studytonight.com/data-structures/time-complexity-of-algorithms}}\cf0 \expnd0\expndtw0\kerning0
\ulnone \
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Conclusion
\b0 \expnd0\expndtw0\kerning0
: In general, \
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
\ul O(n)
\b0 \expnd0\expndtw0\kerning0
\ulnone  - doing something with every item in on dimension is linear, \

\b \expnd0\expndtw0\kerning0
\ul O(n2)
\b0 \expnd0\expndtw0\kerning0
\ulnone  - doing something with every item in tow dimension is quadratic, and \

\b \expnd0\expndtw0\kerning0
\ul log(n)
\b0 \expnd0\expndtw0\kerning0
\ulnone  - dividing the working area in half is logarithmic.\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Time Complexity Notations:
\b0 \expnd0\expndtw0\kerning0
\
Big Oh - fewer than or the same as\
Big Omega - more than or the same as\
Big Theta - the same as\
Little Oh - fewer than\
Little Omega - more than\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
\ul Sorting Algorithms
\b0 \expnd0\expndtw0\kerning0
\ulnone \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0
\i \cf0 \kerning1\expnd0\expndtw0 {\listtext	
\f2\i0 \uc0\u8259 
\f1\i 	}\expnd0\expndtw0\kerning0
Simple
\i0 \expnd0\expndtw0\kerning0
 - Insertion, Selection\
\ls5\ilvl0
\i \kerning1\expnd0\expndtw0 {\listtext	
\f2\i0 \uc0\u8259 
\f1\i 	}\expnd0\expndtw0\kerning0
Efficient
\i0 \expnd0\expndtw0\kerning0
 - Merge, Heap, Quick\
\ls5\ilvl0
\i \kerning1\expnd0\expndtw0 {\listtext	
\f2\i0 \uc0\u8259 
\f1\i 	}\expnd0\expndtw0\kerning0
Bubble
\i0 \expnd0\expndtw0\kerning0
 - Bubble, Shell, Comb\
\ls5\ilvl0
\i \kerning1\expnd0\expndtw0 {\listtext	
\f2\i0 \uc0\u8259 
\f1\i 	}\expnd0\expndtw0\kerning0
Distribution
\i0 \expnd0\expndtw0\kerning0
 - Counting, Bucket, Radix\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Bubble sort
\b0 \expnd0\expndtw0\kerning0
 compares all the elements one by one and sort them based on their values. With each iteration the smaller element in the list bubbles up towards the first place.\
Sorting takes place by stepping through all the data items one by one in pairs and comparing adjacent data items and swapping each pair that is out of order.\

\b \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n) when list is already sorted, 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n2), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n2)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(1), just for temp.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic Bubble-sort-example-300px.gif \width6000 \height3600
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f1 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Insertion Sort
\b0 \expnd0\expndtw0\kerning0
: Sorts the array by shifting elements one by one. It does not change the order of element means if there are two same digits with different insertion order then this algorithm will maintain the insertion order. \

\b \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n) when list is already sorted, 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n2), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n2)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(1), just for key.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic Insertion-sort-example-300px.gif \width6000 \height3600
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural
\cf0  \'97\'97 {{\NeXTGraphic insertion-sort.png \width7365 \height5805
}¬}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f1 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Selection Sort
\b0 \expnd0\expndtw0\kerning0
: It first finds the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continues in this way until entire array is sorted.\

\b \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n2), 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n2), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n2)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(1), just for key.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic Selection-Sort-Animation.gif \width2000 \height7420
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f1 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Quick Sort:
\b0 \expnd0\expndtw0\kerning0
 Its not stable sort, but very fast and requires very less additional space. Partition-Exchange Sort or Comparison Sort or Divided & Conquer algorithm, It first divides a large array into two smaller sub-arrays: the low elements and the high elements. The bast case of the recursion is arrays of size zero or one, which never need to be sorted. Quicksort can then recursively sort the sub-arrays.\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls6\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Pick an element, called a 
\b \expnd0\expndtw0\kerning0
pivot
\b0 \expnd0\expndtw0\kerning0
, from the array.\
\ls6\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the 
\b \expnd0\expndtw0\kerning0
partition
\b0 \expnd0\expndtw0\kerning0
 operation.\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls6\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	3.	}{\field{\*\fldinst{HYPERLINK "http://wikipedia.moesalih.com/wiki/Recursion_(computer_science)"}}{\fldrslt \expnd0\expndtw0\kerning0
\ul Recursively}}\cf0 \expnd0\expndtw0\kerning0
 apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n2)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(n log n).\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic quick-sort.png \width7440 \height5295
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural
\cf0  \'97\'97 {{\NeXTGraphic Quicksort-example.gif \width6000 \height3600
}¬}{{\NeXTGraphic Sorting_quicksort_anim.gif \width5600 \height4280
}¬}
\f1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Merge Sort: 
\b0 \expnd0\expndtw0\kerning0
Comparison based sorting algorithm, it follows Divide & Conquer rule but it doesn\'92t divide the list into two halves. The unsorted list is divided into N sublist, each having one element, because list of one element considered sorted. Then, it repeatedly merge these sublists, to produce new sorted sublists, and at lasts one sorted list is produced. Best suited for linked-list sorting.\

\b \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n log n)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(n).\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic Merge-sort-example-300px.gif \width6000 \height3600
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural
\cf0 {{\NeXTGraphic Merge_sort_algorithm_diagram.svg copy.png \width8000 \height7700
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f1 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Heap Sort
\b0 \expnd0\expndtw0\kerning0
: One of the best sorting method and with no quadratic worst-case scenarios.\
- Creating a Heap of unsorted list.\
- Then a sorted array is created by repeatedly removing the largest/smallest element from heap and inserting it into the array. The heap is reconstructed after each removal.\
\

\b \expnd0\expndtw0\kerning0
Heap
\b0 \expnd0\expndtw0\kerning0
: Its a special tree based data structure, that satisfies the following heap properties:\
- 
\b \expnd0\expndtw0\kerning0
Shape Property
\b0 \expnd0\expndtw0\kerning0
: Its always a 
\b \expnd0\expndtw0\kerning0
Complete Binary Tree
\b0 \expnd0\expndtw0\kerning0
, which means all levels of the tree are fully filled. With NO missing node.\
- 
\b \expnd0\expndtw0\kerning0
Heap Property
\b0 \expnd0\expndtw0\kerning0
: All nodes are either [greater than or equal to] or [less than or equal to] each of its children element. If the parent nodes are greater than their children, heap is called a 
\b \expnd0\expndtw0\kerning0
Max-Heap
\b0 \expnd0\expndtw0\kerning0
, and if the parent nodes are smaller than their child nodes, heap is called 
\b \expnd0\expndtw0\kerning0
Min-Heap
\b0 \expnd0\expndtw0\kerning0
.\

\b \expnd0\expndtw0\kerning0
Work
\b0 \expnd0\expndtw0\kerning0
: First step is to create a heap data structure (max-heap or min-heap). Once heap is built, the first element is either largest or smallest, so we put the first element (top node) in our array. Then we again make heap using remaining elements, to again pick the first element of the heap and put it into the array. We keep doing this, until we have the complete sorted array.\

\b \expnd0\expndtw0\kerning0
Time Comp:
\b0 \expnd0\expndtw0\kerning0
 
\b \expnd0\expndtw0\kerning0
B
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
A
\b0 \expnd0\expndtw0\kerning0
: O(n log n), 
\b \expnd0\expndtw0\kerning0
W
\b0 \expnd0\expndtw0\kerning0
: O(n log n)\

\b \expnd0\expndtw0\kerning0
Space Comp:
\b0 \expnd0\expndtw0\kerning0
 O(n).\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f0 \cf0 \kerning1\expnd0\expndtw0 {{\NeXTGraphic Heapsort-example.gif \width7000 \height5600
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural
\cf0 {{\NeXTGraphic heap-property-example.png \width8205 \height5745
}¬}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural

\f1 \cf0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf0 \expnd0\expndtw0\kerning0
\
\'97\'97\'97\
\
\pard\pardeftab720

\b \cf0 \expnd0\expndtw0\kerning0
Stack
\b0 \expnd0\expndtw0\kerning0
 is abstract data type with abounded (predefined) capacity. It is a simple DS that allows adding and removing elements in a particular order. Every time an element is added, it goes on the top of the stack, the only element that can be removed is from the top of the stack, just like pile of objects.\
Features:\
- It is an ordered list of similar data types.\
- It is a LIFO structure (Last In First Out).\
- push() and pop() can execute only from one end which is Top of stack.\
- Overflow state, when completely full, Underflow state, when completely empty.\
Applications of stack: Reverse a word, Parsing, Expression Conversion, etc.\
Implementation: Easily implemented using an Array or a Linked List.\
Push / Pop / Top Operation: O(1)\
Search Operation: O(n)\
\
\'97\'97\'97\
\

\b \expnd0\expndtw0\kerning0
Queue
\b0 \expnd0\expndtw0\kerning0
 is also an abstract data type or a linear data structure, works in FIFO order, elements added from REAR or TAIL, deletion takes place from FRONT or HEAD. Adding of elements called Enqueue, removing elements called Dequeue.\
Features:\
- Like Stack, Queue is an ordered list of elements of similar data types.\
- A FIFO (First In First Out) structure.\
- peek() function is used to return the value of first element without Dequeueing it.\
Applications: Printer, CPU task scheduling etc.\
Implementation: It can be implemented using an Array, Stack or linked list.\
Enqueue: O(1)\
Dequeue: O(1)\
Size: O(1)\
\
\'97\'97\'97\
\

\b \expnd0\expndtw0\kerning0
Recursion?
\b0 \expnd0\expndtw0\kerning0
\
A recursive algorithm calls itself which usually passes the return value as a parameter to the algorithm again. This parameter is the input while the return value is the output.\
\

\b \expnd0\expndtw0\kerning0
Recursive Algorithm?
\b0 \expnd0\expndtw0\kerning0
\
Recursive algorithm is a method of simplification that divides the problem into sub-problems of the same nature. The result of one recursion is the input for the next recursion. The repletion is in the self-similar fashion. The algorithm calls itself with smaller input values and obtains the results by simply performing the operations on these smaller values. 
\i \expnd0\expndtw0\kerning0
Generation of factorial, Fibonacci number series are the examples of recursive algorithms.
\i0 \expnd0\expndtw0\kerning0
\
\

\b \expnd0\expndtw0\kerning0
malloc():
\b0 \expnd0\expndtw0\kerning0
 \
1. Allocates memory blocks and returns a void pointer to allocated space.\
2. Takes only one argument which is the memory required in bytes. \
3. It does not initialise memory allocated.\

\b \expnd0\expndtw0\kerning0
calloc():
\b0 \expnd0\expndtw0\kerning0
 \
1. It calls malloc internally. Allocates block of memory for an array of elements of a certain size.\
2. Takes two arguments, size of array (number of variables to allocate memory for) and bytes for each array element (size in bytes of a single variable).\
3. It initialises the allocated memory to zero 0.\
\

\b \expnd0\expndtw0\kerning0
const char* p:
\b0 \expnd0\expndtw0\kerning0
 The character is constant pointed by p, value of p can never be change but p can point to different location.\

\b \expnd0\expndtw0\kerning0
char const* p: 
\b0 \expnd0\expndtw0\kerning0
The pointer is constant not the character referenced by p, p cannot point to different location but value of char can be changed pointed by p.\
If you're not dealing with a pointer, const int and int const are exactly the same. NSStrings are already immutable, so the const only needs to be applied to the pointer (which can be a little confusing since Objective-C objects are always accessed via pointers\
\

\b \expnd0\expndtw0\kerning0
void pointer:
\b0 \expnd0\expndtw0\kerning0
 A C convention for a raw address. The compiler has no idea what type of object a void pointer really points to. int *p; (points to int) where void *p; (p does not point to void.)\
\

\b \expnd0\expndtw0\kerning0
void:
\b0 \expnd0\expndtw0\kerning0
 ??\
\

\b \expnd0\expndtw0\kerning0
const and volatile variables:
\b0 \expnd0\expndtw0\kerning0
\
\

\b \expnd0\expndtw0\kerning0
Pointer Value & Address:
\b0 \expnd0\expndtw0\kerning0
 Pointer value is a data object that refer to a memory location. Each memory location is numbered in memory. The number attached to a memory location is called the address of the location.\
\

\b \expnd0\expndtw0\kerning0
Static memory allocation:
\b0 \expnd0\expndtw0\kerning0
 The compiler allocates the required memory for a declared variable 
\i \expnd0\expndtw0\kerning0
at compile time
\i0 \expnd0\expndtw0\kerning0
 only by using the address of operator. \

\b \expnd0\expndtw0\kerning0
Dynamic memory allocation:
\b0 \expnd0\expndtw0\kerning0
 It uses functions like malloc() or calloc() to get memory dynamically 
\i \expnd0\expndtw0\kerning0
at runtime
\i0 \expnd0\expndtw0\kerning0
.\
\

\b \expnd0\expndtw0\kerning0
Binary Search Tree
\b0 \expnd0\expndtw0\kerning0
\
This method is very effective, as each iteration reduced the number of items to search by one-half. However, since data was stored in an array, insertions and deletions were not efficient. Binary search trees store data in nodes that are linked in a tree-like fashion. For randomly inserted data, search time is 
\i\b \expnd0\expndtw0\kerning0
O
\i0\b0 \expnd0\expndtw0\kerning0
(lg 
\i \expnd0\expndtw0\kerning0
n
\i0 \expnd0\expndtw0\kerning0
). Worst-case behavior occurs when ordered data is inserted. In this case the search time is 
\i\b \expnd0\expndtw0\kerning0
O
\i0\b0 \expnd0\expndtw0\kerning0
(
\i \expnd0\expndtw0\kerning0
n
\i0 \expnd0\expndtw0\kerning0
).\
\

\b \expnd0\expndtw0\kerning0
Hashing:
\b0 \expnd0\expndtw0\kerning0
 Building a data structure that can be searched in O(1) time. This concept is referred to as 
\b \expnd0\expndtw0\kerning0
hashing
\b0 \expnd0\expndtw0\kerning0
.\
A 
\b \expnd0\expndtw0\kerning0
hash table
\b0 \expnd0\expndtw0\kerning0
 is a collection of items which are stored in such a way as to make it easy to find them later. Each position of the hash table, often called a slot, can hold an item and is named by an integer value starting at 0. For example, we will have a slot named 0, a slot named 1, a slot named 2, and so on. Initially, the hash table contains no items so every slot is empty. \
The mapping between an item and the slot where that item belongs in the hash table is called the 
\b \expnd0\expndtw0\kerning0
hash function
\b0 \expnd0\expndtw0\kerning0
. The hash function will take any item in the collection and return an integer in the range of slot names, between 0 and m-1. \
\

\b \expnd0\expndtw0\kerning0
Other Points:
\b0 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls7\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
A linked list can be circular.\
\ls7\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Storage type in C: Automatic, Static, and Allocated\
}